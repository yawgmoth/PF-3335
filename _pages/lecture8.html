
<!DOCTYPE html>
<html>
  <head>
    <title>Lecture 8: Decompositional Planning</title>
    <meta charset="utf-8">
    <style>
      @import url(https://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
      @import url(https://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic);
      @import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);

      body { font-family: 'Droid Serif'; font-size: 2em; }
      h1, h2, h3 {
        font-family: 'Yanone Kaffeesatz';
        font-weight: normal;
      }
      p { font-size: 1.25em; }
      div { font-size: 1.25em; }
      li { font-size: 1.25em; }
      li p { line-height: 1.25em; font-size: 1.25em; }
      .red { color: #fa0000; }
      .large { font-size: 2em; }
      
      .small li {  font-size: 1em; }
      
      .oneline li { font-size: 1.25em; line-height: 1.25em; }
      .oneline li p { font-size: 1.25em; line-height: 1.25em; }
      .oneline p { font-size: 1.25em; line-height: 1.25em; }
      .oneline div { font-size: 1.25em; line-height: 1.25em; }
      
      .remark-code, .remark-inline-code { font-family: 'Ubuntu Mono'; }
      
      .medium li {  font-size: 1.1em; }
     
      .mmedium li {  font-size: 1.05em; }
      
        
      .left-column {
        color: #777;
        width: 40%;
        height: 92%;
        float: left;
      }
        .left-column h2:last-of-type, .left-column h3:last-child {
          color: #000;
        }
      .right-column {
        width: 60%;
        float: right;
        padding-top: 1em;
        font-size: 1em;
      }
    </style>
  </head>
  <body>
    <textarea id="source">

class: center, middle

# Artificial Intelligence: Planning

### Decompositional Planning

---

# Review: The Planning Problem

A planning problem consists of three parts:

  * A definition of the current state of the world
  
  * A definition of a desired state of the world
  
  * A definition of the actions the agent can take
  
---

class: medium

# Let's take a step back 

* How would a human solve a complex problem?

* For example, say we have 5 packages, 2 trucks and 40 cities 

* A "natural" way would be to take the large problem and divide it into smaller problems 

* One part may be "move package 1 from its origin to its destination"

* But each of these parts is still a "complex problem"

---

class: medium

# Interactions 

* Once we have solved all the "complex problems", we have a plan!

* However, the solutions for each part may interact or overlap

* For example, if we drive a package from Limón to Liberia, and another one from San José to Alajuela, we may combine these two plans into one 

* On the other hand, if we drive a package from Limón to San José, and another from San Ramon to Punta Arenas, we need to come up with a plan to fill the gap

---

# Planning 

* This approach of "take a complex problem and split it into smaller subproblems" is not just natural to humans, it is also common in algorithms

* Let's see if we can apply it to planning 

* We probably have to augment our formalism with some way to represent decomposition

---

class: center, middle 

# DPOCL

---

# Review: POCL

* Last week we talked about partial-order causal link planning 

* Our graph consisted of nodes representing plans 

* To transition from one plan to another we would use "refinement operations"

* Let's use the same idea for decompositions

---

# Abstract Actions

* We always assumed that actions were what the agent could execute in the end 

* What if we have something more abstract, like "go to the airport"

* There may be many ways to achieve such an abstract action, like going by car, by taxi, by train

* Some ways only work in certain situations (not all airports have train connections)

---

# Abstract Actions 

* Just as with our regular actions, let's assume that an abstract action has preconditions and effects

* That means our POCL planning process can just insert abstract actions to satisfy other actions' preconditions 

* However, we need a new type of flaw because abstract actions can not be executed

---

# Decompositions 

* To define how an abstract action can actually be performed we define "decompositions"

* Basically, we say that to perform an abstract action we instead perform a set of several other actions 

* Of course, these other actions may also be abstract, leading to a hierarchy of decompositions 

* So what *is* a decomposition?

---

class: medium

# Decompositions 

* You can imagine a decomposition to be like a "mini-plan"

* The abstract action has some preconditions and effects 

* The decomposition has these preconditions as an initial state, and the effects as the goal 

* Additionally, the decomposition adds "pseudo-steps" to the plan

* We **require** that all preconditions and effects are used by causal links connected to these pseudo-steps


---

class: medium

# Pseudo-Steps

* We could just replace an abstract action by its decomposition 

* However, in many cases we want to "reuse" some steps 

* For example, we have an abstract action "go on vacation", and another "buy a gift"

* One may involve going to the airport, the other going to a store, but there are often stores at airports

---

# Review: The POP algorithm 

1. If we don't have any flaws, return the current plan 

2. Non-deterministically choose a flaw 

3. Refine the plan to fix the flaw (note: this may generate new flaws!)

4. Call POP on the newly refined plan

---

# DPOCL 

* We can reuse POP by adding a new flaw type and new refinements 

* New flaw: Abstract Action without decomposition 

* New refinement: Apply decomposition 

* New refinement: Merge pseudo-steps

---

# Discourse Planning 

* One particularly well-suited domain for decompositional planning is conveying information

* Take a scientific paper: The paper consists of sections, which each have their own preconditions and effects, each section consists of a series of paragraphs, and each paragraph consists of sentences

* The "preconditions" and "effects" are of the form "the reader knows x"

---

class: center, middle 

# Hierarchical Task Networks

---

class: medium

# Hierarchical Task Networks (HTN)

* Planning based on task decomposition 

* The "domain" in this case is a set of decomposition rules, or "methods"

* The "goal" is to achieve a task 

* Each method describes how one task can be decomposed into smaller tasks 

* There may be multiple methods for each task

---

# HTN Formalisms

---

# HTN Complexity 

* HTN planning is (depending on the exact formulation) Turing-complete

* Some reduced HTN formalisms can be *compiled* to PDDL

---

# Homework

* [Homework 8](/PF-3335/assets/pdf/homework8.pdf) has been posted on the class website
  
* There are 4 problems 

* One problem is about DPOCL 

* The other three use PyHOP: Download the code and play around with it

---

# References
 
  * Young, R. M. [DPOCL: A Principled Approach to Discourse Planning](https://www.aclweb.org/anthology/W94-0302.pdf)

    </textarea>
    <script src="https://remarkjs.com/downloads/remark-latest.min.js">
    </script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS_HTML&delayStartupUntil=configured" type="text/javascript"></script>

    <script>
      var slideshow = remark.create();
      
      // Setup MathJax
      MathJax.Hub.Config({
          tex2jax: {
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre']
          }
      });

      MathJax.Hub.Configured();
    </script>
  </body>
</html>